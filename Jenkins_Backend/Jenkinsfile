// Jenkinsfile - Declarative Pipeline for Smart Retail Project with DR Failover

pipeline {
    agent any

    environment {
        // Docker Hub config
        DOCKER_HUB_ORG = "rani19"
        DOCKER_HUB_IMAGE_TAG = "${env.BUILD_NUMBER}"

        // Compose service names
        MAIN_BACKEND_SERVICE = "backend"
        MAIN_FRONTEND_SERVICE = "main-frontend"
        DR_BACKEND_SERVICE = "dr-backend"
        DR_FRONTEND_SERVICE = "dr-frontend"
        MAIN_DB_SERVICE = "main-db"
        PGADMIN_SERVICE = "pgadmin"

        // Health URLs
        MAIN_BACKEND_HEALTH_URL = "http://localhost:5001/health"
        MAIN_FRONTEND_HEALTH_URL = "http://localhost:3000/"
        DR_BACKEND_HEALTH_URL = "http://localhost:5002/health"
        DR_FRONTEND_HEALTH_URL = "http://localhost:3002/"

        HEALTH_CHECK_RETRIES = 10
        HEALTH_CHECK_INTERVAL_SECONDS = 5
        HEALTH_CHECK_TIMEOUT_SECONDS = 60
    }

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }

    stages {
        stage('Checkout Source') {
            steps {
                cleanWs()
                script {
                    checkout scm
                }
            }
        }

        stage('Build Docker Images (Docker Compose)') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        sh "echo \"$DOCKER_PASSWORD\" | docker login -u \"$DOCKER_USERNAME\" --password-stdin"
                    }
                    sh "DOCKER_BUILDKIT=1 docker compose build"
                }
            }
        }

        stage('Run Unit Tests (Example)') {
            steps {
                script {
                    echo "Running unit tests (placeholder)..."
                    sh "echo 'Unit tests completed.'"
                }
            }
        }

        stage('Start Docker Compose Services') {
            steps {
                script {
                    sh "docker compose down --remove-orphans"
                    sleep 5
                    sh "docker compose up -d"
                }
            }
        }

        stage('Run Kubernetes Port Forwards') {
            steps {
                script {
                    sh "chmod +x scripts/start-dev.sh"
                    sh "scripts/start-dev.sh"
                }
            }
        }

        stage('Health Check Services') {
            steps {
                script {
                    def checkHealth = { name, url ->
                        echo "üß™ Checking ${name} at ${url}..."
                        def retries = env.HEALTH_CHECK_RETRIES as int
                        def interval = env.HEALTH_CHECK_INTERVAL_SECONDS as int
                        def success = false
                        for (int i = 0; i < retries; i++) {
                            def code = sh(script: "curl -s -o /dev/null -w '%{http_code}' ${url} || echo 000", returnStdout: true).trim()
                            if (["200", "301", "302"].contains(code)) {
                                echo "‚úÖ ${name} healthy (HTTP ${code})"
                                success = true
                                break
                            } else {
                                echo "‚ùå ${name} HTTP ${code} - retrying in ${interval}s"
                                sleep interval
                            }
                        }
                        if (!success) {
                            error "‚ùå ${name} failed health check."
                        }
                    }

                    parallel {
                        stage('Main Backend') { steps { checkHealth("Main Backend", MAIN_BACKEND_HEALTH_URL) } }
                        stage('Main Frontend') { steps { checkHealth("Main Frontend", MAIN_FRONTEND_HEALTH_URL) } }
                        stage('DR Backend') { steps { checkHealth("DR Backend", DR_BACKEND_HEALTH_URL) } }
                        stage('DR Frontend') { steps { checkHealth("DR Frontend", DR_FRONTEND_HEALTH_URL) } }
                    }
                }
            }
        }

        stage('Failover Check & DR Sync') {
            steps {
                script {
                    echo "üö® Checking Main Backend status for DR decision..."

                    def response = sh(
                        script: "curl -s -o /dev/null -w '%{http_code}' ${MAIN_BACKEND_HEALTH_URL} || echo 000",
                        returnStdout: true
                    ).trim()

                    if (response != "200") {
                        echo "‚ùå Main Backend is DOWN (HTTP ${response}). Activating DR..."

                        sh 'docker start gogo-dr-backend || true'
                        sh 'docker start gogo-dr-frontend || true'

                        echo "üå± Syncing DR backend via seed.py..."
                        sh 'docker exec -i gogo-backend bash -c "python /app/seed.py"'

                        withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_WEBHOOK')]) {
                            sh """
                                curl -X POST -H 'Content-type: application/json' \\
                                --data '{"text": "üö® *Failover Activated*: Main Backend unavailable. DR backend synced."}' $SLACK_WEBHOOK
                            """
                        }

                        echo "‚úÖ DR backend is ready and synced."
                    } else {
                        echo "‚úÖ Main Backend is healthy. No failover needed."
                    }
                }
            }
        }

        stage('Push Docker Images to Registry') {
            steps {
                script {
                    echo "üì¶ Pushing Docker images to ${DOCKER_HUB_ORG}..."
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        def tagAndPush = { service ->
                            sh "docker tag smart-retail-dev-${service}:latest ${DOCKER_HUB_ORG}/${service}:${DOCKER_HUB_IMAGE_TAG}"
                            sh "docker push ${DOCKER_HUB_ORG}/${service}:${DOCKER_HUB_IMAGE_TAG}"
                            sh "docker tag smart-retail-dev-${service}:latest ${DOCKER_HUB_ORG}/${service}:latest"
                            sh "docker push ${DOCKER_HUB_ORG}/${service}:latest"
                        }

                        [MAIN_BACKEND_SERVICE, MAIN_FRONTEND_SERVICE, DR_BACKEND_SERVICE, DR_FRONTEND_SERVICE].each { tagAndPush(it) }
                    }
                    echo "‚úÖ All Docker images pushed successfully."
                }
            }
        }
    }

    post {
        always {
            script {
                echo "--- üßπ Cleanup ---"
                sh "docker compose down --remove-orphans"
                sh "pkill -f \"kubectl port-forward\" || true"
            }
        }

        success {
            echo "‚úÖ Pipeline completed successfully."
        }

        failure {
            echo "‚ùå Pipeline failed. Check logs for more details."
        }
    }
}
