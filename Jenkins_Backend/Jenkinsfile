pipeline {
  agent any // Uses the Jenkins agent, which is your Docker container

  options {
    buildDiscarder(logRotator(numToKeepStr: '5')) // Keep last 5 builds
    timeout(time: 20, unit: 'MINUTES') // Max build time
    skipDefaultCheckout true // We will manage repository cloning explicitly
  }

  environment {
    // --- Your Project Specific Details ---
    IMAGE_NAME = 'rani19/backend'
    TAG = "build-${env.BUILD_NUMBER}"
    DEV_REPO_URL = 'https://github.com/RaniSaed/smart-retail-dev.git'
    CONFIG_REPO_URL = 'https://github.com/RaniSaed/smart-retail-config.git'

    // --- Jenkins Credential IDs ---
    DOCKER_CREDENTIALS_ID = 'docker-hub-creds' // Docker Hub Username/Password credential
    SLACK_CREDENTIAL_ID = 'slack-webhook'     // Slack Webhook URL Secret Text credential
    // GitHub PAT (Secret Text credential in Jenkins).
    // Using this for both username and password in the withCredentials block.
    // The username for PATs in URLs is often just the token itself or 'x-oauth-basic'.
    // Here, we'll pass the token as both username and password via `usernamePassword` binding for flexibility.
    GITHUB_PUSH_TOKEN_CREDENTIAL_ID = 'github-push-token'

    // --- Git Author Details for Commits ---
    GIT_AUTHOR_NAME = 'Jenkins Backend CI'
    GIT_AUTHOR_EMAIL = 'Rani.saed19@gmail.com' // IMPORTANT: Use a relevant email for traceability
  }

  stages {
    stage('üì• Clean Workspace & Clone Dev Repo') {
      steps {
        cleanWs() // Always start with a clean workspace
        dir('dev') { // Clone smart-retail-dev into a 'dev' subdirectory
          script {
            echo "Cloning public development repository: ${DEV_REPO_URL}"
            // Since it's public, credentials are not strictly needed for clone, but for private repos,
            // you'd add credentialsId: 'your-github-credential-id' here.
            git branch: 'main', url: "${DEV_REPO_URL}"
          }
        }
      }
    }

    stage('üïµÔ∏è Check Backend Changes') {
      steps {
        dir('dev') {
          script {
            // Check for changes in the 'backend/' directory relative to the previous commit
            def backendChanged = sh(
              script: "git diff --name-only HEAD~1 HEAD | grep -q '^backend/'",
              returnStatus: true
            ) == 0

            if (!backendChanged) {
              echo "‚ö†Ô∏è No changes detected in backend code. Aborting pipeline."
              currentBuild.result = 'ABORTED'
              error("No changes in backend/ directory. Pipeline aborted.")
            } else {
              echo "‚úÖ Changes detected in backend code. Proceeding with build."
            }
          }
        }
      }
    }

    stage('üê≥ Build Docker Image') {
      steps {
        dir('dev') { // Ensure we are in the 'dev' directory where the backend code resides
          script {
            echo "üì¶ Building Docker image: ${IMAGE_NAME}:${TAG}"
            // Build context is 'backend', Dockerfile is 'backend/Dockerfile'
            // This leverages the mounted /var/run/docker.sock to use the Docker daemon on the host.
            docker.build("${IMAGE_NAME}:${TAG}", "-f backend/Dockerfile backend")
            echo "‚úÖ Docker image built successfully."
          }
        }
      }
    }

    stage('üöÄ Push to Docker Hub') {
      steps {
        // Use withCredentials to securely access Docker Hub credentials
        withCredentials([usernamePassword(credentialsId: "${DOCKER_CREDENTIALS_ID}", usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
          script {
            echo "üîë Logging in to Docker Hub..."
            // Using the Docker Hub credential ID for the registry
            docker.withRegistry("https://index.docker.io/v1/", "${DOCKER_CREDENTIALS_ID}") {
              echo "‚¨ÜÔ∏è Pushing image ${IMAGE_NAME}:${TAG} to Docker Hub..."
              docker.image("${IMAGE_NAME}:${TAG}").push()
              echo "‚¨ÜÔ∏è Pushing image ${IMAGE_NAME}:latest to Docker Hub..."
              docker.image("${IMAGE_NAME}:${TAG}").push("latest") // Also push with the 'latest' tag
              echo "‚úÖ Images pushed to Docker Hub successfully."
            }
          }
        }
      }
    }

    stage('‚öôÔ∏è Clone & Prepare Config Repo') {
      steps {
        script {
          echo "Cloning configuration repository: ${CONFIG_REPO_URL}"
          dir('config') { // Clone smart-retail-config into a dedicated 'config' subdirectory
            // This 'withCredentials' block exposes the GitHub PAT as GIT_USERNAME and GIT_PASSWORD
            // to be used in the Git clone and push URLs.
            withCredentials([usernamePassword(credentialsId: "${GITHUB_PUSH_TOKEN_CREDENTIAL_ID}",
                                              usernameVariable: 'GIT_USERNAME', // The PAT itself can go here for simplicity
                                              passwordVariable: 'GIT_PASSWORD')]) { // And also here
              sh """
                # Configure Git user for commits made by Jenkins
                git config user.name "${GIT_AUTHOR_NAME}"
                git config user.email "${GIT_AUTHOR_EMAIL}"
                # Clone the repository using the PAT for authentication.
                # Since it's a PAT, we can effectively use the token for both username and password here.
                git clone https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/RaniSaed/smart-retail-config.git .
                git checkout main # Ensure we are on the main branch
              """
            }
          }
        }
      }
    }

    stage('‚úçÔ∏è Update K8s Deployment File') {
      steps {
        dir('config') { // Work within the 'config' directory
          script {
            def deploymentFile = "k8s/backend/deployment.yaml"
            echo "Updating image tag in ${deploymentFile} to ${IMAGE_NAME}:${TAG}"
            // Using sed to perform an in-place replacement.
            // This pattern specifically targets 'image: rani19/backend:anything' and replaces 'anything' with the new TAG.
            sh "sed -i 's|image: rani19/backend:.*|image: rani19/backend:${TAG}|g' ${deploymentFile}"
            echo "‚úÖ Deployment file updated."
          }
        }
      }
    }

    stage('‚¨ÜÔ∏è Commit and Push Config Changes') {
      steps {
        dir('config') { // Work within the 'config' directory
          script {
            // Re-access credentials for the push operation
            withCredentials([usernamePassword(credentialsId: "${GITHUB_PUSH_TOKEN_CREDENTIAL_ID}",
                                              usernameVariable: 'GIT_USERNAME',
                                              passwordVariable: 'GIT_PASSWORD')]) {
              echo "Attempting to commit and push changes to smart-retail-config repo."

              // Add the modified file to the staging area
              sh "git add k8s/backend/deployment.yaml"

              // Check if there are any staged changes before committing
              // `git diff --cached --quiet` returns 0 if no changes, non-zero if changes.
              if (sh(script: "git diff --cached --quiet", returnStatus: true) == 0) {
                echo "No changes to commit in the deployment file. Skipping commit and push."
              } else {
                // Commit the changes
                echo "Committing changes..."
                sh "git commit -m 'chore(backend): Update backend image to ${TAG} [skip ci]'" // Added [skip ci] to prevent recursive builds

                // Set the remote URL with credentials for the push operation.
                // This makes the subsequent 'git push origin main' command authenticated.
                sh "git remote set-url origin https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/RaniSaed/smart-retail-config.git"

                // Push the changes to the 'main' branch
                echo "Pushing changes to remote 'main' branch..."
                sh "git push origin main"
                echo "‚úÖ Changes committed and pushed successfully."
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      cleanWs() // Always clean the workspace at the end of the build (success, failure, aborted)
    }
    success {
      script {
        echo "‚úÖ Backend pipeline completed successfully! New image: ${IMAGE_NAME}:${TAG}"
        withCredentials([string(credentialsId: "${SLACK_CREDENTIAL_ID}", variable: 'SLACK_WEBHOOK')]) {
          sh """
            curl -X POST -H 'Content-type: application/json' \
            --data '{"text": "‚úÖ Backend Build Success ‚Äî Image *${IMAGE_NAME}:${TAG}* pushed to Docker Hub and K8s config updated. Jenkins Build: ${env.BUILD_URL}"}' $SLACK_WEBHOOK
          """
        }
      }
    }
    aborted {
      script {
        echo "‚èπÔ∏è Pipeline aborted (no backend changes)."
        withCredentials([string(credentialsId: "${SLACK_CREDENTIAL_ID}", variable: 'SLACK_WEBHOOK')]) {
          sh """
            curl -X POST -H 'Content-type: application/json' \
            --data '{"text": "‚ö†Ô∏è Jenkins Backend Pipeline Aborted ‚Äî No changes detected in backend/ or manually aborted. Jenkins Build: ${env.BUILD_URL}"}' $SLACK_WEBHOOK
          """
        }
      }
    }
    failure {
      script {
        echo "‚ùå Pipeline failed. Check the logs for details."
        withCredentials([string(credentialsId: "${SLACK_CREDENTIAL_ID}", variable: 'SLACK_WEBHOOK')]) {
          sh """
            curl -X POST -H 'Content-type: application/json' \
            --data '{"text": "‚ùå Backend Build Failed ‚Äî Check Jenkins logs for details: ${env.BUILD_URL}"}' $SLACK_WEBHOOK
          """
        }
      }
    }
  }
}